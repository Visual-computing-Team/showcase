<!doctype html><html lang=en-us dir=ltr><head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta name=description content="Image processing # Procesamiento de imágenes # El procesamiento de imágenes es una disciplina que se enfoca en la manipulación y análisis de imágenes digitales con el objetivo de mejorar su calidad, extraer información útil o realizar transformaciones específicas.
El procesamiento de imágenes se basa en la utilización de algoritmos y técnicas específicas para realizar operaciones sobre los píxeles que conforman una imagen. Los píxeles representan los elementos fundamentales de una imagen digital y contienen información sobre su color y posición en el espacio."><meta name=theme-color content="#FFFFFF"><meta name=color-scheme content="light dark"><meta property="og:title" content><meta property="og:description" content="Image processing # Procesamiento de imágenes # El procesamiento de imágenes es una disciplina que se enfoca en la manipulación y análisis de imágenes digitales con el objetivo de mejorar su calidad, extraer información útil o realizar transformaciones específicas.
El procesamiento de imágenes se basa en la utilización de algoritmos y técnicas específicas para realizar operaciones sobre los píxeles que conforman una imagen. Los píxeles representan los elementos fundamentales de una imagen digital y contienen información sobre su color y posición en el espacio."><meta property="og:type" content="article"><meta property="og:url" content="https://Visual-computing-Team/showcase/docs/Taller-2/3-Image-processing/"><meta property="article:section" content="docs"><meta property="article:modified_time" content="2023-06-19T16:20:18-05:00"><title>3) Image Processing | Showcase visual computing team</title><link rel=manifest href=/showcase/manifest.json><link rel=icon href=/showcase/favicon.png type=image/x-icon><link rel=stylesheet href=/showcase/book.min.4b35fed0bea034bbc19c89c71e14b73fb9c68cfcc586b9382adfb9b7b103ba06.css integrity="sha256-SzX+0L6gNLvBnInHHhS3P7nGjPzFhrk4Kt+5t7EDugY=" crossorigin=anonymous><script defer src=/showcase/flexsearch.min.js></script>
<script defer src=/showcase/en.search.min.3a8d658c77eb93c7f12a2b8af49a700131e474f288eefb605d9fa61576dbe5a7.js integrity="sha256-Oo1ljHfrk8fxKiuK9JpwATHkdPKI7vtgXZ+mFXbb5ac=" crossorigin=anonymous></script></head><body dir=ltr><input type=checkbox class="hidden toggle" id=menu-control>
<input type=checkbox class="hidden toggle" id=toc-control><main class="container flex"><aside class=book-menu><div class=book-menu-content><nav><h2 class=book-brand><a class="flex align-center" href=/showcase/><span>Showcase visual computing team</span></a></h2><div class=book-search><input type=text id=book-search-input placeholder=Search aria-label=Search maxlength=64 data-hotkeys=s/><div class="book-search-spinner hidden"></div><ul id=book-search-results></ul></div><ul><li><a href=/showcase/docs/Equipo/>Equipo</a><ul></ul></li><li class=book-section-flat><span>Taller 1</span><ul><li><a href=/showcase/docs/Taller-1/1-Marco-te%C3%B3rico/>1) Marco Teórico</a></li><li><a href=/showcase/docs/Taller-1/2-Daltonismo/>2) Daltonismo</a></li><li><a href=/showcase/docs/Taller-1/3-Aplicaciones-con-daltonismo/>3) Aplicaciones Con Daltonismo</a></li><li><a href=/showcase/docs/Taller-1/4-Luminosidad/>4) Luminosidad</a></li></ul></li><li class=book-section-flat><span>Taller 2</span><ul><li><a href=/showcase/docs/Taller-2/1-Color-Blending/>1) Color Blending</a></li><li><a href=/showcase/docs/Taller-2/2-Procedural-Texturing/>2) Procedural Texturing</a></li><li><a href=/showcase/docs/Taller-2/3-Image-processing/ class=active>3) Image Processing</a></li><li><a href=/showcase/docs/Taller-2/4-PhotoMosaic/>4) Photo Mosaic</a></li><li><a href=/showcase/docs/Taller-2/5-Texturing/>5) Texturing</a></li><li><a href=/showcase/docs/Taller-2/6-geometr%C3%ADa-constructiva-de-s%C3%B3lidos/>6) Geometría Constructiva De Sólidos</a></li><li><a href=/showcase/docs/Taller-2/7-visual-Posteffects/>7) Visual Posteffects</a></li><li><a href=/showcase/docs/Taller-2/8-Uso-de-ChatGPT/>8) Uso De Chat Gpt</a></li></ul></li></ul></nav><script>(function(){var e=document.querySelector("aside .book-menu-content");addEventListener("beforeunload",function(){localStorage.setItem("menu.scrollTop",e.scrollTop)}),e.scrollTop=localStorage.getItem("menu.scrollTop")})()</script></div></aside><div class=book-page><header class=book-header><div class="flex align-center justify-between"><label for=menu-control><img src=/showcase/svg/menu.svg class=book-icon alt=Menu></label>
<strong>3) Image Processing</strong>
<label for=toc-control><img src=/showcase/svg/toc.svg class=book-icon alt="Table of Contents"></label></div><aside class="hidden clearfix"><nav id=TableOfContents><ul><li><a href=#image-processing>Image processing</a><ul><li><a href=#procesamiento-de-imágenes>Procesamiento de imágenes</a></li><li><a href=#convolución>Convolución</a></li><li><a href=#descripción-general>Descripción general</a></li><li><a href=#vertex-shader>Vertex shader</a></li></ul></li><li><a href=#aplicación-1-lupa>Aplicación 1: Lupa</a><ul><li><a href=#procesamiento-de-la-imagen>Procesamiento de la imagen</a></li><li><a href=#fragment-shader>Fragment shader</a><ul><li><a href=#sketch>Sketch</a></li></ul></li><li><a href=#funcionalidad>Funcionalidad</a></li></ul></li><li><a href=#aplicación-2-detección-de-bordes-y-ajuste-de-brillo>Aplicación 2: Detección de bordes y ajuste de brillo</a><ul><li><a href=#procesamiento-de-la-imagen-1>Procesamiento de la imagen</a><ul><li><a href=#fragment-shader-1>Fragment shader</a></li><li><a href=#sketch-1>Sketch</a></li></ul></li><li><a href=#funcionalidad-1>Funcionalidad</a></li><li><a href=#conclusiones>Conclusiones</a></li><li><a href=#referencias>Referencias</a></li></ul></li></ul></nav></aside></header><article class=markdown><h1 id=image-processing>Image processing
<a class=anchor href=#image-processing>#</a></h1><h2 id=procesamiento-de-imágenes>Procesamiento de imágenes
<a class=anchor href=#procesamiento-de-im%c3%a1genes>#</a></h2><p>El procesamiento de imágenes es una disciplina que se enfoca en la manipulación y análisis de imágenes digitales con el objetivo de mejorar su calidad, extraer información útil o realizar transformaciones específicas.</p><p>El procesamiento de imágenes se basa en la utilización de algoritmos y técnicas específicas para realizar operaciones sobre los píxeles que conforman una imagen. Los píxeles representan los elementos fundamentales de una imagen digital y contienen información sobre su color y posición en el espacio. Al aplicar diferentes operaciones sobre estos píxeles, es posible modificar su apariencia, extraer características o realizar análisis cuantitativos.</p><h2 id=convolución>Convolución
<a class=anchor href=#convoluci%c3%b3n>#</a></h2><p>La convolución es una operación fundamental en el procesamiento de imágenes que permite combinar una imagen con un filtro o máscara para resaltar características específicas. Consiste en deslizar el filtro sobre la imagen y realizar multiplicaciones y sumas en cada posición para generar una nueva imagen resultante. La convolución es ampliamente utilizada en el procesamiento de imágenes para aplicar efectos como la detección de bordes, el desenfoque o el realce de detalles.</p><blockquote class="book-hint danger"><p><strong>Consigna</strong><br>implementar una aplicación de procesamiento de imagen/video compatible con diferentes máscaras, incluidos otros tamaños de kernel diferentes a 3x3, y:</p><ul><li>Una herramienta base de región de interés para aplicar selectivamente una máscara determinada.</li><li>Una herramienta de lupa.</li><li>Integre luma y otras herramientas de brillo de color.</li></ul></blockquote><h2 id=descripción-general>Descripción general
<a class=anchor href=#descripci%c3%b3n-general>#</a></h2><p>Para esta aplicación se desarrollaron dos programas, el primero está enfocado en una herramienta de lupa, y el segundo, en una aplicación que realiza efectos de detección de bordes y detección de brillo en una imagen. Los programas utilizan shaders para procesar los píxeles de la imagen y lograr los efectos deseados. El shader <em>vertex</em> se encarga de procesar la geometría de la imagen, mientras que el shader <em>fragment</em> se encarga de calcular el color final de cada píxel en función de los efectos seleccionados.</p><h2 id=vertex-shader>Vertex shader
<a class=anchor href=#vertex-shader>#</a></h2><p>Las dos apliaciones utilizan el mismo vertex shader. Su funcionamiento se describe a continuación.</p><ul><li><p>Invierte verticalmente las coordenadas de textura para que sean compatibles con el sistema gráfico.<blockquote class="book-hint info"><strong>vTexCoord = vec2(aTexCoord.x, 1.0 - aTexCoord.y)</strong>: En esta línea, se asignan las coordenadas de textura al varying vTexCoord. Antes de asignarlas, se realiza una transformación para invertir verticalmente las coordenadas de textura, ya que en algunos sistemas gráficos el origen de las coordenadas de textura se encuentra en la esquina superior izquierda.</blockquote></p></li><li><p>Transforma las coordenadas de posición del vértice al rango [-1, 1] en el espacio de recorte.<blockquote class="book-hint info"><strong>positionVec4.xy = positionVec4.xy * 2.0 - 1.0</strong>: En esta línea, se realiza una transformación lineal para mapear las coordenadas de posición del vértice al rango [-1, 1]. Esto se logra multiplicando las coordenadas por 2.0 y restando 1.0.</blockquote></p></li></ul><details><summary>Vertex shader</summary><div class=markdown-inner><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c++ data-lang=c++><span style=display:flex><span>attribute vec3 aPosition;
</span></span><span style=display:flex><span>attribute vec2 aTexCoord;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>varying vec2 vTexCoord;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>void</span> <span style=color:#a6e22e>main</span>() {
</span></span><span style=display:flex><span>  vTexCoord <span style=color:#f92672>=</span> vec2(aTexCoord.x, <span style=color:#ae81ff>1.0</span> <span style=color:#f92672>-</span> aTexCoord.y); <span style=color:#75715e>// Flip the texture coordinates vertically
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>  vec4 positionVec4 <span style=color:#f92672>=</span> vec4(aPosition, <span style=color:#ae81ff>1.0</span>);
</span></span><span style=display:flex><span>  positionVec4.xy <span style=color:#f92672>=</span> positionVec4.xy <span style=color:#f92672>*</span> <span style=color:#ae81ff>2.0</span> <span style=color:#f92672>-</span> <span style=color:#ae81ff>1.0</span>;
</span></span><span style=display:flex><span>  gl_Position <span style=color:#f92672>=</span> positionVec4;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div></div></details><h1 id=aplicación-1-lupa>Aplicación 1: Lupa
<a class=anchor href=#aplicaci%c3%b3n-1-lupa>#</a></h1><h2 id=procesamiento-de-la-imagen>Procesamiento de la imagen
<a class=anchor href=#procesamiento-de-la-imagen>#</a></h2><p>Dentro del shader, se realiza un bucle para iterar sobre cada píxel de la imagen y aplicar el kernel para obtener la suma de colores resultante . El kernel es una matriz que define cómo se combina cada píxel con sus vecinos adyacentes. En este ejemplo, se utiliza un kernel de identidad que no modifica la imagen original.
A continuación, se verifica si el píxel actual está dentro del radio de la lógica de magnificación. Si es así, se calcula la posición del píxel magnificado utilizando la posición relativa al centro del píxel de magnificación y se obtiene el color correspondiente de la textura de muestra. Si el píxel está fuera del radio de magnificación, se utiliza el color resultante del kernel.</p><h2 id=fragment-shader>Fragment shader
<a class=anchor href=#fragment-shader>#</a></h2><p>Para conseguir el efecto de aumento o lupa, el fragment shader trabaja de la siguiente manera:</p><ul><li>Se calcula el tamaño de un píxel en las coordenadas de textura (<em><strong>onePixel</strong></em>) dividiendo el vector <em><strong>(1.0, 1.0)</strong></em> por la resolución de la pantalla (<em><strong>uResolution</strong></em>).</li><li>Se inicializa <em><strong>colorSum</strong></em> como un vector <em><strong>vec4</strong></em> que almacenará la suma acumulada de los colores resultantes al aplicar el kernel.</li><li>Se utiliza un bucle anidado for para recorrer los valores correspondientes a las filas y columnas del kernel.</li><li>Se calcula el desplazamiento (<em><strong>offset</strong></em>) del píxel actual en función de su posición relativa al centro del kernel.</li><li>Se obtiene el color del píxel vecino correspondiente a la posición desplazada y se multiplica por el valor del kernel correspondiente. El resultado se suma a <em><strong>colorSum</strong></em> para acumular los colores procesados.</li><li>Luego se aplica la lógica de magnificación. Se calcula la distancia desde el píxel actual hasta el centro del área de magnificación utilizando las coordenadas de textura (<em><strong>dx</strong></em> y <em><strong>dy</strong></em>). Si la distancia es menor que el radio del área de magnificación dividido por la resolución horizontal (<em><strong>uMagnifierRadius / uResolution.x</strong></em>), se realiza la magnificación.</li><li>Se calculan las coordenadas de textura magnificadas y se obtiene el color de la textura de muestra (<em><strong>uSampler</strong></em>) en esas coordenadas.</li><li>Si el píxel no está dentro del área de magnificación, se asigna a <em><strong>gl_FragColor</strong></em> el valor acumulado (<em><strong>colorSum</strong></em>).</li></ul><details><summary>Fragment shader lupa</summary><div class=markdown-inner><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c++ data-lang=c++><span style=display:flex><span>precision mediump <span style=color:#66d9ef>float</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>uniform sampler2D uSampler;
</span></span><span style=display:flex><span>uniform vec2 uResolution;
</span></span><span style=display:flex><span>uniform <span style=color:#66d9ef>float</span> uKernelSize;
</span></span><span style=display:flex><span>uniform <span style=color:#66d9ef>float</span> uKernel[<span style=color:#ae81ff>25</span>];
</span></span><span style=display:flex><span>uniform <span style=color:#66d9ef>float</span> uMagnifier;
</span></span><span style=display:flex><span>uniform vec2 uMagnifierCenter;
</span></span><span style=display:flex><span>uniform <span style=color:#66d9ef>float</span> uMagnifierRadius;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>varying vec2 vTexCoord;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>void</span> <span style=color:#a6e22e>main</span>() {
</span></span><span style=display:flex><span>  vec2 onePixel <span style=color:#f92672>=</span> vec2(<span style=color:#ae81ff>1.0</span>, <span style=color:#ae81ff>1.0</span>) <span style=color:#f92672>/</span> uResolution;
</span></span><span style=display:flex><span>  vec4 colorSum <span style=color:#f92672>=</span> vec4(<span style=color:#ae81ff>0.0</span>);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>int</span> i <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>; i <span style=color:#f92672>&lt;</span> <span style=color:#ae81ff>5</span>; i<span style=color:#f92672>++</span>) {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>int</span> j <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>; j <span style=color:#f92672>&lt;</span> <span style=color:#ae81ff>5</span>; j<span style=color:#f92672>++</span>) {
</span></span><span style=display:flex><span>      <span style=color:#66d9ef>if</span> (i <span style=color:#f92672>&lt;</span> <span style=color:#66d9ef>int</span>(uKernelSize) <span style=color:#f92672>&amp;&amp;</span> j <span style=color:#f92672>&lt;</span> <span style=color:#66d9ef>int</span>(uKernelSize)) {
</span></span><span style=display:flex><span>        vec2 offset <span style=color:#f92672>=</span> vec2(<span style=color:#66d9ef>float</span>(i) <span style=color:#f92672>-</span> (uKernelSize <span style=color:#f92672>-</span> <span style=color:#ae81ff>1.0</span>) <span style=color:#f92672>/</span> <span style=color:#ae81ff>2.0</span>, <span style=color:#66d9ef>float</span>(j) <span style=color:#f92672>-</span> (uKernelSize <span style=color:#f92672>-</span> <span style=color:#ae81ff>1.0</span>) <span style=color:#f92672>/</span> <span style=color:#ae81ff>2.0</span>) <span style=color:#f92672>*</span> onePixel;
</span></span><span style=display:flex><span>        colorSum <span style=color:#f92672>+=</span> texture2D(uSampler, vec2(vTexCoord.x <span style=color:#f92672>+</span> offset.x, vTexCoord.y <span style=color:#f92672>+</span> offset.y)) <span style=color:#f92672>*</span> uKernel[j <span style=color:#f92672>*</span> <span style=color:#ae81ff>5</span> <span style=color:#f92672>+</span> i];
</span></span><span style=display:flex><span>      }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#75715e>// Magnifier logic
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>  <span style=color:#66d9ef>float</span> dx <span style=color:#f92672>=</span> vTexCoord.x <span style=color:#f92672>-</span> uMagnifierCenter.x;
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>float</span> dy <span style=color:#f92672>=</span> vTexCoord.y <span style=color:#f92672>-</span> uMagnifierCenter.y;
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>float</span> distance <span style=color:#f92672>=</span> sqrt(dx <span style=color:#f92672>*</span> dx <span style=color:#f92672>+</span> dy <span style=color:#f92672>*</span> dy);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>if</span> (distance <span style=color:#f92672>&lt;</span> uMagnifierRadius <span style=color:#f92672>/</span> uResolution.x) {
</span></span><span style=display:flex><span>    vec2 direction <span style=color:#f92672>=</span> vec2(dx, dy);
</span></span><span style=display:flex><span>    vec2 magnifiedTexCoord <span style=color:#f92672>=</span> uMagnifierCenter <span style=color:#f92672>+</span> direction <span style=color:#f92672>*</span> uMagnifier;
</span></span><span style=display:flex><span>    gl_FragColor <span style=color:#f92672>=</span> texture2D(uSampler, magnifiedTexCoord);
</span></span><span style=display:flex><span>  } <span style=color:#66d9ef>else</span> {
</span></span><span style=display:flex><span>    gl_FragColor <span style=color:#f92672>=</span> colorSum;
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div></div></details><h3 id=sketch>Sketch
<a class=anchor href=#sketch>#</a></h3><details><summary>Sketch lupa</summary><div class=markdown-inner><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-js data-lang=js><span style=display:flex><span><span style=color:#66d9ef>function</span> <span style=color:#a6e22e>draw</span>() {
</span></span><span style=display:flex><span><span style=color:#75715e>// Update magnifier center and radius based on mouse input
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>  <span style=color:#66d9ef>let</span> <span style=color:#a6e22e>magnifierCenter</span> <span style=color:#f92672>=</span> [<span style=color:#a6e22e>mouseX</span> <span style=color:#f92672>/</span> <span style=color:#a6e22e>width</span>, <span style=color:#a6e22e>mouseY</span> <span style=color:#f92672>/</span> <span style=color:#a6e22e>height</span>];
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>let</span> <span style=color:#a6e22e>magnifierRadius</span> <span style=color:#f92672>=</span> <span style=color:#a6e22e>circleSizeSlider</span>.<span style=color:#a6e22e>value</span>();
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>shaderProgram</span>.<span style=color:#a6e22e>setUniform</span>(<span style=color:#e6db74>&#39;uMagnifierCenter&#39;</span>, <span style=color:#a6e22e>magnifierCenter</span>);
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>shaderProgram</span>.<span style=color:#a6e22e>setUniform</span>(<span style=color:#e6db74>&#39;uMagnifierRadius&#39;</span>, <span style=color:#a6e22e>magnifierRadius</span>);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#75715e>// Set the kernel and magnifier values
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>  <span style=color:#66d9ef>let</span> <span style=color:#a6e22e>kernel</span> <span style=color:#f92672>=</span> [ <span style=color:#75715e>// Example: Identity kernel
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#ae81ff>0</span>, <span style=color:#ae81ff>0</span>, <span style=color:#ae81ff>0</span>,
</span></span><span style=display:flex><span>    <span style=color:#ae81ff>0</span>, <span style=color:#ae81ff>1</span>, <span style=color:#ae81ff>0</span>,
</span></span><span style=display:flex><span>    <span style=color:#ae81ff>0</span>, <span style=color:#ae81ff>0</span>, <span style=color:#ae81ff>0</span>
</span></span><span style=display:flex><span>  ];
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>let</span> <span style=color:#a6e22e>kernelSize</span> <span style=color:#f92672>=</span> <span style=color:#ae81ff>9</span>;
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>let</span> <span style=color:#a6e22e>magnifier</span> <span style=color:#f92672>=</span> <span style=color:#ae81ff>2</span> <span style=color:#f92672>-</span> <span style=color:#a6e22e>magnificationFactorSlider</span>.<span style=color:#a6e22e>value</span>();
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>shaderProgram</span>.<span style=color:#a6e22e>setUniform</span>(<span style=color:#e6db74>&#39;uKernelSize&#39;</span>, <span style=color:#a6e22e>kernelSize</span>);
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>shaderProgram</span>.<span style=color:#a6e22e>setUniform</span>(<span style=color:#e6db74>&#39;uKernel&#39;</span>, <span style=color:#a6e22e>kernel</span>);
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>shaderProgram</span>.<span style=color:#a6e22e>setUniform</span>(<span style=color:#e6db74>&#39;uMagnifier&#39;</span>, <span style=color:#a6e22e>magnifier</span>);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>rect</span>(<span style=color:#ae81ff>0</span>, <span style=color:#ae81ff>0</span>, <span style=color:#a6e22e>img</span>.<span style=color:#a6e22e>width</span>, <span style=color:#a6e22e>img</span>.<span style=color:#a6e22e>height</span>);
</span></span><span style=display:flex><span>}
</span></span></code></pre></div></div></details><h2 id=funcionalidad>Funcionalidad
<a class=anchor href=#funcionalidad>#</a></h2><p>El programa carga una imagen y la presenta en el canva. El usuario puede interactuar pasando el cursor sobre la imagen para visualizar el efecto de lupa. Así mismo puede modificar el tamaño del círculo de aplicación y la intensidad del efecto haciendo uso de los sliders.</p><p><blockquote class="book-hint warning"><ul><li>Se pueden utilizar las teclas + y - para aumentar o reducir la intensidad del efecto.</li><li>Para modificar el tamaño del círculo es posible hacerlo con las teclas de izquierda (←) y derecha (→)</li></ul></blockquote><iframe id="magnifier.js?version=4" style=width:620px;height:630px srcdoc="
        <!DOCTYPE html>
        <html>
          <head>
            <script src=https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.5.0/p5.min.js></script>
            <script src=https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.5.0/addons/p5.sound.min.js></script>
            
            
            
            
            
            <script src=/showcase/sketches/magnifier.js?version=4></script>
          </head>
          <body>
          </body>
        </html>
      "></iframe></p><h1 id=aplicación-2-detección-de-bordes-y-ajuste-de-brillo>Aplicación 2: Detección de bordes y ajuste de brillo
<a class=anchor href=#aplicaci%c3%b3n-2-detecci%c3%b3n-de-bordes-y-ajuste-de-brillo>#</a></h1><h2 id=procesamiento-de-la-imagen-1>Procesamiento de la imagen
<a class=anchor href=#procesamiento-de-la-imagen-1>#</a></h2><p>El shader procesa la imagen píxel por píxel, aplicando la máscara seleccionada y calculando el valor final del píxel en función de los efectos y parámetros configurados. Se utilizan técnicas de convolución y operaciones matemáticas para obtener los resultados deseados.</p><h3 id=fragment-shader-1>Fragment shader
<a class=anchor href=#fragment-shader-1>#</a></h3><h4 id=detección-de-bordes-con-kernel-de-máscara-de-convolución>Detección de bordes con kernel de máscara de convolución
<a class=anchor href=#detecci%c3%b3n-de-bordes-con-kernel-de-m%c3%a1scara-de-convoluci%c3%b3n>#</a></h4><p>Para determinar el valor de un pixel luego de aplicarle una máscara de convolución con un kernel determinado se usa la función auxiliar <em><strong>getKernelValue</strong></em>:</p><p>Esta función toma como argumentos row y col (fila y columna) para obtener el valor del kernel de detección de bordes correspondiente a esa posición. El valor se determina según los tipos de máscara y tamaño del kernel especificados en las variables uniformes. Dependiendo de los valores de effectType y maskType, se establecen diferentes valores para cada posición del kernel. A continuación se detallan los tipos de máscaras utilizadas:</p><div class=book-tabs><input type=radio class=toggle name=tabs-edge-detector id=tabs-edge-detector-0 checked>
<label for=tabs-edge-detector-0>Laplacian of Gaussian</label><div class="book-tabs-content markdown-inner"><img src=/showcase/sketches/log.png></div><input type=radio class=toggle name=tabs-edge-detector id=tabs-edge-detector-1>
<label for=tabs-edge-detector-1>Laplacian</label><div class="book-tabs-content markdown-inner"><img src=/showcase/sketches/laplacian.png></div><input type=radio class=toggle name=tabs-edge-detector id=tabs-edge-detector-2>
<label for=tabs-edge-detector-2>Sobel</label><div class="book-tabs-content markdown-inner"><img src=/showcase/sketches/sobel.png></div><input type=radio class=toggle name=tabs-edge-detector id=tabs-edge-detector-3>
<label for=tabs-edge-detector-3>Kirsch</label><div class="book-tabs-content markdown-inner"><img src=/showcase/sketches/kirsch.png></div><input type=radio class=toggle name=tabs-edge-detector id=tabs-edge-detector-4>
<label for=tabs-edge-detector-4>Robinson</label><div class="book-tabs-content markdown-inner"><img src=/showcase/sketches/robinson.png></div><input type=radio class=toggle name=tabs-edge-detector id=tabs-edge-detector-5>
<label for=tabs-edge-detector-5>Roberts</label><div class="book-tabs-content markdown-inner"><img src=/showcase/sketches/roberts.png></div></div><p>Para el caso de la detección de brillo se hizo uso de las siguientes máscaras de convolución</p><div class=book-tabs><input type=radio class=toggle name=tabs-brightness id=tabs-brightness-0 checked>
<label for=tabs-brightness-0>HSV</label><div class="book-tabs-content markdown-inner"><img src=/showcase/sketches/br_hsv.png></div><input type=radio class=toggle name=tabs-brightness id=tabs-brightness-1>
<label for=tabs-brightness-1>RGB</label><div class="book-tabs-content markdown-inner"><img src=/showcase/sketches/br_rgb.png></div><input type=radio class=toggle name=tabs-brightness id=tabs-brightness-2>
<label for=tabs-brightness-2>LUMA</label><div class="book-tabs-content markdown-inner"><img src=/showcase/sketches/br_luma.png></div></div><blockquote class="book-hint info">Dado que al trabajar con diferentes tamaños de kernel, las matrices de convolución se complejizan a medida que se incrementa el tamaño, solo se trabajó con diferentes tamaños de kernel usando la matriz de convolución <strong>Laplacian of Gaussian</strong></blockquote><h4 id=efecto-de-detección-de-bordes-o-filtrado>Efecto de detección de bordes o filtrado:
<a class=anchor href=#efecto-de-detecci%c3%b3n-de-bordes-o-filtrado>#</a></h4><ul><li><p><strong>vec2 onePixel = vec2(1.0, 1.0) / uResolution</strong>: Se calcula el tamaño de un píxel en relación a la resolución de la pantalla.</p></li><li><p><strong>vec4 colorSum = vec4(0.0)</strong>: Se inicializa una variable para almacenar la suma acumulada de colores.</p></li><li><p>El bucle for anidado se utiliza para iterar a través de cada posición del kernel y calcular la suma ponderada de los colores de la textura de entrada. La suma se realiza multiplicando el color de la textura en cada posición del kernel con el valor correspondiente obtenido de getKernelValue, y luego se acumula en colorSum.</p></li><li><p><strong>float edge = length(colorSum)</strong>: Se calcula la magnitud del vector colorSum para obtener el valor del borde.</p></li><li><p>Se calcula la posición del píxel actual en relación a la posición del círculo y se calcula la distancia entre ellos. Si la distancia entre el píxel y el centro del círculo es menor que el radio del círculo, se asigna un nuevo color al fragmento utilizando <em><strong>gl_FragColor</strong></em>. El color se basa en la intensidad del efecto multiplicada por el valor del borde calculado anteriormente. Esto genera un efecto visual dentro del círculo.
En caso contrario, se asigna el color original de la textura al fragmento utilizando <em><strong>gl_FragColor</strong></em>.</p></li></ul><details><summary>Fragment shader</summary><div class=markdown-inner><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c++ data-lang=c++><span style=display:flex><span>precision mediump <span style=color:#66d9ef>float</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>uniform sampler2D uSampler;
</span></span><span style=display:flex><span>uniform vec2 uResolution;
</span></span><span style=display:flex><span>uniform <span style=color:#66d9ef>int</span> uApplyEffect;
</span></span><span style=display:flex><span>uniform vec2 uCirclePosition;
</span></span><span style=display:flex><span>uniform <span style=color:#66d9ef>float</span> uCircleRadius;
</span></span><span style=display:flex><span>uniform <span style=color:#66d9ef>float</span> uEffectIntensity;
</span></span><span style=display:flex><span>uniform <span style=color:#66d9ef>float</span> edgeDetectionKernel[<span style=color:#ae81ff>25</span>];
</span></span><span style=display:flex><span>uniform <span style=color:#66d9ef>int</span> maskType;
</span></span><span style=display:flex><span>uniform <span style=color:#66d9ef>int</span> kernelSize;
</span></span><span style=display:flex><span>uniform <span style=color:#66d9ef>int</span> effectType;
</span></span><span style=display:flex><span>varying vec2 vTexCoord;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>float</span> <span style=color:#a6e22e>getKernelValue</span>(<span style=color:#66d9ef>int</span> row, <span style=color:#66d9ef>int</span> col) {
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>if</span>(effectType <span style=color:#f92672>==</span> <span style=color:#ae81ff>1</span>){
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>int</span> middle <span style=color:#f92672>=</span> kernelSize <span style=color:#f92672>/</span> <span style=color:#ae81ff>2</span>;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>float</span> center_value;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>float</span> default_value;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span>(maskType <span style=color:#f92672>==</span> <span style=color:#ae81ff>0</span> <span style=color:#f92672>||</span> kernelSize <span style=color:#f92672>&gt;</span> <span style=color:#ae81ff>3</span>){ <span style=color:#75715e>//LAPLACIAN OF GAUSSIAN
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>      default_value <span style=color:#f92672>=</span> <span style=color:#f92672>-</span><span style=color:#ae81ff>1.0</span>;
</span></span><span style=display:flex><span>      <span style=color:#66d9ef>if</span>(kernelSize <span style=color:#f92672>==</span> <span style=color:#ae81ff>3</span>) center_value <span style=color:#f92672>=</span> <span style=color:#ae81ff>8.0</span>;
</span></span><span style=display:flex><span>      <span style=color:#66d9ef>if</span>(kernelSize <span style=color:#f92672>==</span> <span style=color:#ae81ff>5</span>) center_value <span style=color:#f92672>=</span> <span style=color:#ae81ff>24.0</span>;
</span></span><span style=display:flex><span>      <span style=color:#66d9ef>if</span>(kernelSize <span style=color:#f92672>==</span> <span style=color:#ae81ff>7</span>) center_value <span style=color:#f92672>=</span> <span style=color:#ae81ff>48.0</span>;
</span></span><span style=display:flex><span>      <span style=color:#66d9ef>if</span>(kernelSize <span style=color:#f92672>==</span> <span style=color:#ae81ff>9</span>) center_value <span style=color:#f92672>=</span> <span style=color:#ae81ff>72.0</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    }<span style=color:#66d9ef>else</span> <span style=color:#66d9ef>if</span>(maskType <span style=color:#f92672>==</span> <span style=color:#ae81ff>1</span>){<span style=color:#75715e>//LAPLACIAN
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>      default_value <span style=color:#f92672>=</span> <span style=color:#ae81ff>0.0</span>;
</span></span><span style=display:flex><span>      center_value <span style=color:#f92672>=</span> <span style=color:#ae81ff>4.0</span>;
</span></span><span style=display:flex><span>    .
</span></span><span style=display:flex><span>    .
</span></span><span style=display:flex><span>    .
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>if</span>(row <span style=color:#f92672>==</span> middle <span style=color:#f92672>&amp;&amp;</span> col <span style=color:#f92672>==</span> middle) <span style=color:#66d9ef>return</span> center_value;
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>return</span> default_value;
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>void</span> main() { 
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>if</span>(maskType <span style=color:#f92672>&lt;=</span> <span style=color:#ae81ff>5</span>){
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>      vec2 onePixel <span style=color:#f92672>=</span> vec2(<span style=color:#ae81ff>1.0</span>, <span style=color:#ae81ff>1.0</span>) <span style=color:#f92672>/</span> uResolution;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>      vec4 colorSum <span style=color:#f92672>=</span> vec4(<span style=color:#ae81ff>0.0</span>);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>      <span style=color:#66d9ef>if</span>(kernelSize <span style=color:#f92672>==</span> <span style=color:#ae81ff>3</span>){
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>int</span> i <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>; i <span style=color:#f92672>&lt;</span> <span style=color:#ae81ff>3</span>; i<span style=color:#f92672>++</span>) {
</span></span><span style=display:flex><span>          <span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>int</span> j <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>; j <span style=color:#f92672>&lt;</span> <span style=color:#ae81ff>3</span>; j<span style=color:#f92672>++</span>) {
</span></span><span style=display:flex><span>            vec2 offset <span style=color:#f92672>=</span> vec2(<span style=color:#66d9ef>float</span>(i) <span style=color:#f92672>-</span> <span style=color:#ae81ff>2.0</span>, <span style=color:#66d9ef>float</span>(j) <span style=color:#f92672>-</span> <span style=color:#ae81ff>2.0</span>) <span style=color:#f92672>*</span> onePixel;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>            vec4 kernel <span style=color:#f92672>=</span> vec4(getKernelValue(i, j));
</span></span><span style=display:flex><span>            colorSum <span style=color:#f92672>+=</span> texture2D(uSampler, vTexCoord <span style=color:#f92672>+</span> offset) <span style=color:#f92672>*</span> kernel;
</span></span><span style=display:flex><span>          }
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>      }
</span></span><span style=display:flex><span>      .
</span></span><span style=display:flex><span>      .
</span></span><span style=display:flex><span>      .
</span></span><span style=display:flex><span>      <span style=color:#66d9ef>float</span> edge <span style=color:#f92672>=</span> length(colorSum);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>      vec2 pixelPosition <span style=color:#f92672>=</span> vTexCoord <span style=color:#f92672>*</span> uResolution;
</span></span><span style=display:flex><span>      <span style=color:#66d9ef>float</span> distance <span style=color:#f92672>=</span> length(pixelPosition <span style=color:#f92672>-</span> uCirclePosition);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>      <span style=color:#66d9ef>if</span> (uApplyEffect <span style=color:#f92672>==</span> <span style=color:#ae81ff>1</span> <span style=color:#f92672>&amp;&amp;</span> distance <span style=color:#f92672>&lt;</span> uCircleRadius) {
</span></span><span style=display:flex><span>        gl_FragColor <span style=color:#f92672>=</span> vec4(vec3(edge <span style=color:#f92672>*</span> uEffectIntensity), <span style=color:#ae81ff>1.0</span>);
</span></span><span style=display:flex><span>      } <span style=color:#66d9ef>else</span> {
</span></span><span style=display:flex><span>        gl_FragColor <span style=color:#f92672>=</span> texture2D(uSampler, vTexCoord);
</span></span><span style=display:flex><span>      }
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div></div></details><p>Se hizo una última implementación para la detección de bordes sin usar máscara de convolución:</p><ul><li>Se realiza un cálculo similar al anterior para obtener los valores de borde en las direcciones horizontal (colorX) y vertical (colorY).</li><li>Se selecciona el mayor valor entre edgeX y edgeY como el valor de borde final (edge).</li><li>Se realiza el cálculo de la distancia y la comprobación de uApplyEffect igual a 1, similar al caso anterior, para aplicar el efecto en el fragmento dentro del círculo.</li></ul><details><summary>Detección de bordes sin máscara de convolución</summary><div class=markdown-inner><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c++ data-lang=c++><span style=display:flex><span>vec2 onePixel <span style=color:#f92672>=</span> vec2(<span style=color:#ae81ff>1.0</span>, <span style=color:#ae81ff>1.0</span>) <span style=color:#f92672>/</span> uResolution;
</span></span><span style=display:flex><span>vec4 color <span style=color:#f92672>=</span> texture2D(uSampler, vTexCoord);
</span></span><span style=display:flex><span>vec4 colorX <span style=color:#f92672>=</span> texture2D(uSampler, vTexCoord <span style=color:#f92672>+</span> vec2(onePixel.x, <span style=color:#ae81ff>0.0</span>));
</span></span><span style=display:flex><span>vec4 colorY <span style=color:#f92672>=</span> texture2D(uSampler, vTexCoord <span style=color:#f92672>+</span> vec2(<span style=color:#ae81ff>0.0</span>, onePixel.y));
</span></span><span style=display:flex><span><span style=color:#66d9ef>float</span> edgeX <span style=color:#f92672>=</span> length(color <span style=color:#f92672>-</span> colorX);
</span></span><span style=display:flex><span><span style=color:#66d9ef>float</span> edgeY <span style=color:#f92672>=</span> length(color <span style=color:#f92672>-</span> colorY);
</span></span><span style=display:flex><span><span style=color:#66d9ef>float</span> edge <span style=color:#f92672>=</span> max(edgeX, edgeY);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>// Calculate the distance from the current pixel to the circle center
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>vec2 pixelPosition <span style=color:#f92672>=</span> vTexCoord <span style=color:#f92672>*</span> uResolution;
</span></span><span style=display:flex><span><span style=color:#66d9ef>float</span> distance <span style=color:#f92672>=</span> length(pixelPosition <span style=color:#f92672>-</span> uCirclePosition);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>if</span> (uApplyEffect <span style=color:#f92672>==</span> <span style=color:#ae81ff>1</span> <span style=color:#f92672>&amp;&amp;</span> distance <span style=color:#f92672>&lt;</span> uCircleRadius) {
</span></span><span style=display:flex><span>  <span style=color:#75715e>// Apply the effect with the specified intensity
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>  gl_FragColor <span style=color:#f92672>=</span> vec4(vec3(edge <span style=color:#f92672>*</span> uEffectIntensity), <span style=color:#ae81ff>1.0</span>);
</span></span><span style=display:flex><span>} <span style=color:#66d9ef>else</span> {
</span></span><span style=display:flex><span>  gl_FragColor <span style=color:#f92672>=</span> color; <span style=color:#75715e>// Display the original image for pixels outside the circle
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>}
</span></span></code></pre></div></div></details><h3 id=sketch-1>Sketch
<a class=anchor href=#sketch-1>#</a></h3><details><summary>Sketch edge-detector</summary><div class=markdown-inner><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-js data-lang=js><span style=display:flex><span><span style=color:#66d9ef>function</span> <span style=color:#a6e22e>draw</span>() {
</span></span><span style=display:flex><span>  <span style=color:#75715e>// Update the circle position based on mouse input
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>  <span style=color:#66d9ef>let</span> <span style=color:#a6e22e>circleCenter</span> <span style=color:#f92672>=</span> [<span style=color:#a6e22e>mouseX</span> <span style=color:#f92672>*</span> <span style=color:#a6e22e>pixelDensity</span>(), <span style=color:#a6e22e>mouseY</span> <span style=color:#f92672>*</span> <span style=color:#a6e22e>pixelDensity</span>()];
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>shaderProgram</span>.<span style=color:#a6e22e>setUniform</span>(<span style=color:#e6db74>&#39;effectType&#39;</span>, <span style=color:#a6e22e>radio</span>.<span style=color:#a6e22e>value</span>());
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>shaderProgram</span>.<span style=color:#a6e22e>setUniform</span>(<span style=color:#e6db74>&#39;maskType&#39;</span>, <span style=color:#a6e22e>maskType</span>);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#75715e>// Pass circle position, radius, and effect intensity to the shader
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>  <span style=color:#a6e22e>shaderProgram</span>.<span style=color:#a6e22e>setUniform</span>(<span style=color:#e6db74>&#39;uCirclePosition&#39;</span>, <span style=color:#a6e22e>circleCenter</span>);
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>shaderProgram</span>.<span style=color:#a6e22e>setUniform</span>(<span style=color:#e6db74>&#39;uCircleRadius&#39;</span>,<span style=color:#a6e22e>circleSizeSlider</span>.<span style=color:#a6e22e>value</span>());
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>shaderProgram</span>.<span style=color:#a6e22e>setUniform</span>(<span style=color:#e6db74>&#39;uEffectIntensity&#39;</span>, <span style=color:#a6e22e>effectSlider</span>.<span style=color:#a6e22e>value</span>());
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>shaderProgram</span>.<span style=color:#a6e22e>setUniform</span>(<span style=color:#e6db74>&#39;uApplyEffect&#39;</span>, <span style=color:#ae81ff>1</span>);
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>shaderProgram</span>.<span style=color:#a6e22e>setUniform</span>(<span style=color:#e6db74>&#39;kernelSize&#39;</span>, <span style=color:#a6e22e>kernelSize</span>);
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>rect</span>(<span style=color:#ae81ff>0</span>, <span style=color:#ae81ff>0</span>, <span style=color:#a6e22e>width</span>, <span style=color:#a6e22e>height</span>);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>if</span> (<span style=color:#a6e22e>keyIsPressed</span>) {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> (<span style=color:#a6e22e>keyCode</span> <span style=color:#f92672>===</span> <span style=color:#a6e22e>LEFT_ARROW</span>) {
</span></span><span style=display:flex><span>      <span style=color:#a6e22e>circleSizeSlider</span>.<span style=color:#a6e22e>value</span>(<span style=color:#a6e22e>circleSizeSlider</span>.<span style=color:#a6e22e>value</span>() <span style=color:#f92672>-</span> <span style=color:#ae81ff>1</span>);
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> (<span style=color:#a6e22e>keyCode</span> <span style=color:#f92672>===</span> <span style=color:#a6e22e>RIGHT_ARROW</span>) {
</span></span><span style=display:flex><span>      <span style=color:#a6e22e>circleSizeSlider</span>.<span style=color:#a6e22e>value</span>(<span style=color:#a6e22e>circleSizeSlider</span>.<span style=color:#a6e22e>value</span>() <span style=color:#f92672>+</span> <span style=color:#ae81ff>1</span>);
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> (<span style=color:#a6e22e>key</span> <span style=color:#f92672>===</span> <span style=color:#e6db74>&#39;+&#39;</span>) {
</span></span><span style=display:flex><span>      <span style=color:#a6e22e>effectSlider</span>.<span style=color:#a6e22e>value</span>(<span style=color:#a6e22e>effectSlider</span>.<span style=color:#a6e22e>value</span>() <span style=color:#f92672>+</span> <span style=color:#ae81ff>0.005</span>);
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> (<span style=color:#a6e22e>key</span> <span style=color:#f92672>===</span> <span style=color:#e6db74>&#39;-&#39;</span>) {
</span></span><span style=display:flex><span>      <span style=color:#a6e22e>effectSlider</span>.<span style=color:#a6e22e>value</span>(<span style=color:#a6e22e>effectSlider</span>.<span style=color:#a6e22e>value</span>() <span style=color:#f92672>-</span> <span style=color:#ae81ff>0.005</span>);
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>effectIntensity</span> <span style=color:#f92672>=</span> <span style=color:#a6e22e>constrain</span>(<span style=color:#a6e22e>effectIntensity</span>, <span style=color:#ae81ff>0</span>, <span style=color:#ae81ff>1</span>);
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div></div></details><h2 id=funcionalidad-1>Funcionalidad
<a class=anchor href=#funcionalidad-1>#</a></h2><p>El programa carga una imagen y la muestra en un canva. Utiliza un shader para aplicar un efecto de detección de bordes o ajuste de brillo, según la selección del usuario. El usuario puede ajustar el tamaño de un círculo y la intensidad del efecto mediante controles deslizantes. El programa también permite cambiar entre diferentes tipos de máscaras de detección de bordes y ajuste de brillo seleccionando opciones en un menú desplegable.</p><p><blockquote class="book-hint warning"><h3 id=modo-de-uso>Modo de uso
<a class=anchor href=#modo-de-uso>#</a></h3><ul><li><p>Al inicio se debe seleccionar alguno de los dos efectos disponibles: Edge-detector o Brightness. De lo contrario solo verá un circulo negro. Luego de seleccionar se mostrará una lista desplegable para seleccionar el tipo de máscara de convolución que se desea usar.</p></li><li><p>Para cambiar el tamaño del kernel usando los botones 3, 5, 7 y 9 para alternar entre kernel de tamaño 3x3, 5x5, 7x7 y 9x9 respectivamente.<br><br></p></li><li><p>Se pueden utilizar las teclas + y - para aumentar o reducir la intensidad del efecto.</p></li><li><p>Para modificar el tamaño del círculo es posible hacerlo con las teclas de izquierda (←) y derecha (→)<br><br></p></li><li><p>Si algún efecto no se visualiza correctamente (se ve el círculo totalmente negro o totalmente blanco) considere reducir o aumentar la intensidad del efecto utilizando el segundo slider.</p></li></ul></blockquote><iframe id="edgeDetector.js?version=4" style=width:750px;height:600px srcdoc="
        <!DOCTYPE html>
        <html>
          <head>
            <script src=https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.5.0/p5.min.js></script>
            <script src=https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.5.0/addons/p5.sound.min.js></script>
            
            
            
            
            
            <script src=/showcase/sketches/edgeDetector.js?version=4></script>
          </head>
          <body>
          </body>
        </html>
      "></iframe></p><h2 id=conclusiones>Conclusiones
<a class=anchor href=#conclusiones>#</a></h2><blockquote class="book-hint info"><ul><li><p>El uso de shaders en la aplicación permite procesar la imagen en tiempo real, lo que significa que los usuarios pueden ajustar los parámetros del filtro y del efecto en cuestión y estos cambios realizados se reflejan instantáneamente en la pantalla. Esto proporciona una retroalimentación inmediata y permite explorar diferentes configuraciones y efectos visuales. Al mismo tiempo permite crear una aplicación interactiva, brindando una experiencia dinámica y personalizada.</p></li><li><p>El proyecto define varios tipos de máscaras, como el Laplaciano de Gaussiana, Laplaciano, Sobel, Kirsch, Robinson y Roberts. Cada tipo de máscara tiene una estructura y configuración específica.</p></li><li><p>Las máscaras tienen diferentes tamaños, como 3x3, 5x5, 7x7 y 9x9. El tamaño de la máscara afecta la cantidad de píxeles vecinos considerados en la operación de convolución y, por lo tanto, puede tener un impacto en el resultado final.</p></li><li><p>Cada máscara tiene una matriz de convolución con elementos que determinan el peso o la contribución de los píxeles vecinos en la operación de convolución. Estos valores pueden afectar la detección de características o el realce de ciertos elementos en la imagen.</p></li></ul></blockquote><h2 id=referencias>Referencias
<a class=anchor href=#referencias>#</a></h2><blockquote class="book-hint danger"><p>El código antes presentado fue realizado en colaboración con la herramienta de procesado de lenguaje Chat GPT y recursos disponibles en la web</p><ul><li><a href=https://anirban-karchaudhuri.medium.com/edge-detection-methods-comparison-9e4b75a9bf87>Edge Detection Methods Comparison</a></li></ul></blockquote></article><footer class=book-footer><div class="flex flex-wrap justify-between"><div><a class="flex align-center" href=https://github.com/visualcomputing/showcase/commit/4f9255986919665d65745a9a31ed3d430d63266b title='Last modified by AndersonVargas8 | June 19, 2023' target=_blank rel=noopener><img src=/showcase/svg/calendar.svg class=book-icon alt=Calendar>
<span>June 19, 2023</span></a></div></div><script>(function(){function e(e){const t=window.getSelection(),n=document.createRange();n.selectNodeContents(e),t.removeAllRanges(),t.addRange(n)}document.querySelectorAll("pre code").forEach(t=>{t.addEventListener("click",function(){if(window.getSelection().toString())return;e(t.parentElement),navigator.clipboard&&navigator.clipboard.writeText(t.parentElement.textContent)})})})()</script></footer><div class=book-comments></div><label for=menu-control class="hidden book-menu-overlay"></label></div><aside class=book-toc><div class=book-toc-content><nav id=TableOfContents><ul><li><a href=#image-processing>Image processing</a><ul><li><a href=#procesamiento-de-imágenes>Procesamiento de imágenes</a></li><li><a href=#convolución>Convolución</a></li><li><a href=#descripción-general>Descripción general</a></li><li><a href=#vertex-shader>Vertex shader</a></li></ul></li><li><a href=#aplicación-1-lupa>Aplicación 1: Lupa</a><ul><li><a href=#procesamiento-de-la-imagen>Procesamiento de la imagen</a></li><li><a href=#fragment-shader>Fragment shader</a><ul><li><a href=#sketch>Sketch</a></li></ul></li><li><a href=#funcionalidad>Funcionalidad</a></li></ul></li><li><a href=#aplicación-2-detección-de-bordes-y-ajuste-de-brillo>Aplicación 2: Detección de bordes y ajuste de brillo</a><ul><li><a href=#procesamiento-de-la-imagen-1>Procesamiento de la imagen</a><ul><li><a href=#fragment-shader-1>Fragment shader</a></li><li><a href=#sketch-1>Sketch</a></li></ul></li><li><a href=#funcionalidad-1>Funcionalidad</a></li><li><a href=#conclusiones>Conclusiones</a></li><li><a href=#referencias>Referencias</a></li></ul></li></ul></nav></div></aside></main></body></html>